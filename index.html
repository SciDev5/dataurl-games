<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' file: 'unsafe-inline' data:">
    <title>DATAURL GAMES</title>
    <style>
        body {
            background: #272728;
            color: #ffffff;
            font-family: monospace;
        }
        #d-in, #a-in {
            display: inline-block;
            padding: 2em;
            margin: 1em;
            background: #3399ff44;
            border-left: 2px solid #777;
        }
        #d-in.drag, #a-in:hover {
            background: #ffffff;
            color: #000000;
        }
        button, input, #use-base64-contain {
            background: #000000;
            border: none;
            font-family: monospace;
            color: #ffffff;
            padding: .5em;
        }
        button:hover, input:active, #use-base64-contain:hover {
            background: #777777;
        }
        #title-in {
            border-left: 2px solid #777;
        }

        #converter {
            padding: 1em;
            margin: 1em;
        }
        #converter a {
            overflow: hidden;
            color: #ffffff;
        }

        #f-out {
            width: 100%;
            height: calc(100vh - 17.5em);
            border: none;
            border-left: 2px solid #777777;
            background: #202022;
        }
    </style>
</head>
<body>
    <script id="prefix-code">
        /* Document tools */
        let $=document,
            _e=(e,p)=>(p??$.body).appendChild($.createElement(e)),
            _c=(...m)=>{let c=_e("canvas");return[c,c.getContext(...m)]},
        /* Utilities */
            __s=(e,s)=>Object.entries(s).forEach(([k,v])=>e[k]=v)||e,
            __a=(l,f)=>new Array(l).fill().map((_,i)=>f(i)),
        /* Events */
            _h=(...e)=>addEventListener(...e),
        /* Loops */
            _lf,
            _ln,
            _lc=_=>cancelAnimationFrame(_lf),
            _ls=f=>{_lc();_ln=()=>{f();_lf=requestAnimationFrame(_ln)};_ln()},
        /* Assets */
            _ae=_e("div"),
            _aj=_at=i=>_ad[i],
            _ai=i=>{const g=_e("img",_ae);g.src=_ad[i];return g};
        _ae.style.display="none";
    </script>
    <div id="inputs">
        <div id="d-in">DROP CODE FILES AND ASSETS HERE [ .JS / .CSS / './ASSETS/' ]</div>
    </div>
    <div id="converter">
        <button id="conv">FORCE REFRESH</button>
        <span id="use-base64-contain">Use Base64: <span id="use-base64">FALSE</span></span>
        <a id="d-out" target="_blank"></a>
    </div>
    <input id="title-in" placeholder="program title"/>
    <iframe id="f-out"></iframe>
    <script defer>// @ts-check
    (async()=>{
        const LOGSTYLE = {
            code:"border-left: 2px solid #777;background:#0077ff44;margin:.5em 1em;padding:.5em",
            checking:"opacity:0.5;background:#ff770022;",
            retranspiling:"padding:1em 2em;margin:1em 0em;text-align:center;font-weight:bold;border-bottom:2px solid #777;background:#3399ff44;",
            complete:"padding:1em 2em;margin:1em 0em;text-align:center;font-weight:bold;border-bottom:2px solid #777;background:#33ff9922;",
        };

        const REGEXES = {
            multilineComment: /\/\*(.|\r?\n)*?\*\//g,
            lineBreak: /\s*\r?\n\s*/g,
            inlineComment: /\/\/.*$/,
        }

        const prefixCode = document.getElementById("prefix-code").textContent.replace(REGEXES.multilineComment,"").replace(REGEXES.lineBreak,"");
        /** @type {FileSystemFileHandle} */
        let inputCodeFileHandle;
        /** @type {FileSystemFileHandle} */
        let inputStyleFileHandle;
        /** @type {FileSystemDirectoryHandle} */
        let inputAssetsDirectoryHandle;
        /** @type {<T extends HTMLElement>(q:string)=>T} */
        const dqs=s=>document.querySelector(s);

        console.log("%cPrefix Code:\n%s",LOGSTYLE.code,prefixCode);

        const dIn = dqs("#d-in");
        /** @type {HTMLButtonElement} */
        const convBtn = dqs("#conv");
        /** @type {HTMLLinkElement} */
        const dOut = dqs("#d-out");
        /** @type {HTMLIFrameElement} */
        const fOut = dqs("#f-out");
        /** @type {HTMLInputElement} */
        const titleIn = dqs("#title-in");
        const useBase64In = dqs("#use-base64");
        const useBase64InContain = dqs("#use-base64-contain");

        let lastEditedCode = -Infinity;
        let lastEditedStyle = -Infinity;
        let lastEditedAssets = "";
        let lastTitleIn = "";
        let lastUseBase64 = false, useBase64 = false;
        

        /** @type {(text:string,lenLimit:number)=>string} */
        const textLenLimit = (text,lenLimit)=>text.length>lenLimit?text.slice(0,lenLimit)+"...":text;

        /** @type {(ms:number)=>Promise<void>} */
        const delay = (ms)=>new Promise(res=>setTimeout(res,ms));

        /** @type {(blob:Blob)=>Promise<string>} */
        const blobToDataURL = (blob)=>new Promise(res=>{
            const reader = new FileReader();
            // @ts-ignore
            reader.onload = ()=>res(reader.result);
            reader.readAsDataURL(blob);
        });

        /** @type {(toEscape:string)=>string} */
        const lazyURLEncode = s=>s.replace(/[%#!?]|\s/g,v=>`%${(()=>{const s=v.charCodeAt(0).toString(16);return "0".repeat(2-s.length)+s})()}`)


        /** @type {{[type in "code"|"style"]:(strIn:string)=>string}} */
        const format = {
            style: raw=>raw
                .replace(REGEXES.multilineComment,"")
                .replace(/\s+/g," ")
                .replace(/ ?([{};:]) ?/g,"$1")
                .trim(),
            code: raw=>{
                const codeDecommented = raw.replace(REGEXES.multilineComment,"").split(REGEXES.lineBreak).slice(2).map(v=>
                    v.replace(REGEXES.inlineComment,"").trim()
                ).filter(v=>v.length>0).join("");
                let codeDespaced = "", wasEscape = false, wasSpace = false, wasBreaker = false;
                /** @type {false|"'"|"\""|"`"|"/"} */
                let inString = false;
                for (const ch of codeDecommented) {
                    if (inString) {
                        if (ch === inString && !wasEscape) {
                            inString = false;
                            wasBreaker = true;
                        }
                        codeDespaced += ch;
                    } else {
                        const isSpace = /\s/.test(ch), isBreaker = /[=+-,./\\[\](){}|&*!`^'"<>?~#;:]/.test(ch);
                        if (ch === "'" || ch === "\"" || ch === "`" || ch === "/")
                            inString = ch;
                        if (isBreaker)
                            codeDespaced = codeDespaced.trim();
                        if (!isSpace)
                            codeDespaced += ch;
                        else if (!wasBreaker)
                            codeDespaced += " ";
                        wasSpace = isSpace;
                        wasBreaker = isSpace || isBreaker;
                    }
                    wasEscape = ch === "\\";
                }
                return codeDespaced;
            }
        }

        const convert = async()=>{
            if (!inputCodeFileHandle) return;
            console.log("%cchecking...",LOGSTYLE.checking);
            
            const lastEditedAssetsNow = inputAssetsDirectoryHandle ? (
                await traverseAssets(async(path,ns,key,handle)=>
                    handle.getFile().then(f=>`${f.lastModified}:${path}:${ns}:${key}`)
                )
            ).sort().join("::") : "";

            const
                fTFile = await inputCodeFileHandle.getFile(), fSFile = await inputStyleFileHandle?.getFile();
            if (
                fTFile.lastModified <= lastEditedCode &&
                (!fSFile || fSFile.lastModified <= lastEditedStyle) &&
                lastEditedAssets === lastEditedAssetsNow &&
                lastTitleIn === titleIn.value &&
                lastUseBase64 === useBase64
            ) return;
            lastEditedAssets = lastEditedAssetsNow;
            lastEditedCode = fTFile.lastModified;
            lastTitleIn = titleIn.value;
            lastUseBase64 = useBase64;
            if (fSFile) lastEditedStyle = fSFile.lastModified;

            console.log("%c%s",LOGSTYLE.retranspiling,"RETRANSPILING");
            const
                title = titleIn.value||"unnamed",
                formattedStyle = fSFile ? format.style(await fSFile.text()) : "",
                formattedCode = format.code(await fTFile.text());

            const assetsList = inputAssetsDirectoryHandle ? await traverseAssets(async(path,ns,key,handle)=>{
                /** @type {File} */
                const file = await handle.getFile();
                return {
                    data: await ({
                        "text/plain": async()=>await file.text(),
                        "application/json": async()=>JSON.parse(await file.text()),
                    }[file.type] ?? (async()=>await blobToDataURL(new Blob([await file.arrayBuffer()],{type:file.type}))))(),
                    key: `${ns}:${key}`,
                };
            }) : [];
            /** @type {{[key:string]:any}} */
            const assetsByKey = {};
            assetsList.forEach(({data,key})=>assetsByKey[key]=data);

            const formattedAssetsLoader = `let _ad=${JSON.stringify(assetsByKey)};`


            console.log("%cLoaded Code:\n%s",LOGSTYLE.code,formattedCode);
            console.log("%cLoaded Style:\n%s",LOGSTYLE.code,formattedStyle);
            console.log("%cLoaded Assets:\n%s",LOGSTYLE.code,assetsList.map(v=>`[${v.key}]|${textLenLimit(JSON.stringify(v.data),50)}`).join("\n") || "<none>");

            console.log("%c%s",LOGSTYLE.complete,"COMPLETED");

            const transpiledHTML = `<title>${title}</title><style>${formattedStyle}</style><body></body><script>${formattedAssetsLoader}${prefixCode+formattedCode}<${""}/script>`;

            const transpiled = useBase64 ?
                await blobToDataURL(new Blob([transpiledHTML],{type:"text/html"})) :
                "data:text/html,"+lazyURLEncode(transpiledHTML);
            dOut.href = transpiled;
            dOut.innerText = textLenLimit(transpiled,50);
            fOut.src = transpiled;
        };
        /** @type {(fileHandle:FileSystemFileHandle,which:"code"|"style")=>void} */
        const setFileHandle = (fileHandle,which)=>{
            if (which === "code") {
                inputCodeFileHandle = fileHandle;
                lastEditedCode = -Infinity;
            }
            if (which === "style") {
                inputStyleFileHandle = fileHandle;
                lastEditedStyle = -Infinity;
            }
            onSetHandle();
        };
        /** @type {(assetsHandle:FileSystemDirectoryHandle)=>Promise<void>} */
        const setAssetsHandle = async(assetsHandle)=>{
            inputAssetsDirectoryHandle = assetsHandle;
            lastEditedAssets = "";
            onSetHandle();
        };
        const onSetHandle = ()=>delay(50).then(()=>convert());

        /** @type {<T>(fn:(path:string,ns:string,key:string,handle:FileSystemFileHandle)=>Promise<T>,dirHandleIn?:FileSystemDirectoryHandle)=>Promise<T[]>} */
        const traverseAssets = async(fn,dirHandleIn)=>{
            /** @type {Promise<any>[]} */
            const promises = [], dirHandle = dirHandleIn ?? inputAssetsDirectoryHandle;

            if (!dirHandle) throw new Error("no assets directory?");

            /** @type {{[ns:string]:{[path:string]:string}}} */
            const manifest = JSON.parse(await (await (await dirHandle.getFileHandle("manifest.json")).getFile()).text());
            for (const ns in manifest) {
                for (const key in manifest[ns]) {
                    const path = manifest[ns][key];
                    promises.push(dirHandle.getFileHandle(path).then(f=>fn(path,ns,key,f)))
                }
            }

            // @ts-ignore
            return await Promise.all(promises);
        }

        /** @type {(elt:HTMLElement,onFile:(f:FileSystemFileHandle|FileSystemDirectoryHandle)=>void)=>void} */
        const fileInput = (elt,onFile)=>{
            elt.addEventListener("dragover",e=>{
                e.preventDefault();
                elt.classList.add("drag");
            });
            elt.addEventListener("dragleave",e=>{
                elt.classList.remove("drag");
            })
            elt.addEventListener("drop",async e=>{
                elt.classList.remove("drag");
                e.preventDefault();
                for (const item of e.dataTransfer.items) {
                    if (item.kind === "file") {
                        // @ts-ignore
                        item.getAsFileSystemHandle().then(onFile);
                    }
                }
            });
            elt.addEventListener("click",async ()=>{
                /** @type {FileSystemDirectoryHandle} */
                // @ts-ignore
                const dir = await showDirectoryPicker(), vals = dir.values();

                /** @type {(FileSystemDirectoryHandle|FileSystemFileHandle)[]} */
                const fileHandles = [];
                for(;;) {
                    /** @type {{done:true,value:null}|{done:false,value:FileSystemDirectoryHandle|FileSystemFileHandle}} */
                    const ent = await vals.next();
                    if (!ent.done)
                        fileHandles.push(ent.value)
                    else break;
                }
                console.log(fileHandles);
                fileHandles.forEach(onFile);
            });
        }

        fileInput(dIn,async f=>{
            if (f.kind === "file") {
                if (/^\.title ([a-zA-Z0-9-_\[\](){}., ])+$/.test(f.name.trim())) {
                    titleIn.value = f.name.slice(7).trim();
                    onSetHandle();
                } else {
                    const type = {
                        js:"code",
                        css:"style",
                        _:"none"
                    }[(f.name.match(/\.(js|css)$/i)??[,"_"])[1]];
                    if (type === "none") return;
                    setFileHandle(f,type);
                }
            } else if (f.kind === "directory") {
                if (f.name === "assets") {
                    const keyRegex = /^\w+$/;
                    const validity = (await traverseAssets(async(path,ns,key)=>{
                        if (!keyRegex.test(ns) || !keyRegex.test(key))
                            return `Asset key [${ns}:${key}] failed: 'ns' or 'key' did not match /${keyRegex}/`
                    },f)).filter(Boolean)
                    setAssetsHandle(f);
                }
            }
        });

        window.addEventListener("focus",e=>convert());
        convBtn.addEventListener("click",convert);

        titleIn.addEventListener("change",e=>convert());
        useBase64InContain.addEventListener("click",e=>{
            useBase64 = !useBase64;
            useBase64In.innerText = (useBase64+"").toUpperCase();
            convert();
        });
        useBase64InContain.addEventListener("mousedown",e=>e.preventDefault());
    })()</script>
</body>
</html>